(iproblems
Problem
p0
(dp1
S'time_limit'
p2
(lp3
VTime Limit: 3 sec
p4
asS'source_limit'
p5
(lp6
VSource Limit: 50000 Bytes
p7
asS'description'
p8
V All submissions for this problem are available.\u000aFinding the longest increasing subsequence is an old and well-known problem now. Here you will have to do something similar. You need to find the longest weird subsequence (LWS) of the given string. The subsequence is called weird if it can be split into two disjoint subsequences, one of which is non-decreasing and the other one is non-increasing.\u000aJust for clarity, by subsequence of the given string S we mean any string that can be obtained from S by erasing from it zero or more characters. So empty string is a subsequence of any string and any string is a subsequence of itself. Further, note that we consider only strings composed of lowercase Latin letters and these letters compared by their ASCII codes. So, for example, 'a' is smaller than 'b' and 'p' is larger than 'h'.\u000aNow let's consider some example. Let S="aabcazcczba". Then "abczz" is its some non-decreasing subsequene, "zccb" is its some non-increasing subsequence and "aabczcczba" is its some weird subsequence since it can be split into non-decreasing subsequence "aabzz" and non-increasing subsequence "cccba": "AABcZccZba" (first subsequence is shown by capital letters just for calrity).\u000aInput\u000aThe first line contains a single positive integer T, the number of test cases. T test cases follow. The only line of each test case contains a non-empty string S composed of lowercase Latin letters.\u000aOutput\u000aFor every test case, output the length of the LWS of the given string.\u000aConstraints\u000a1 \u2264 T \u2264 10\u000a1 \u2264 length of S \u2264 2000\u000aExample\u000aInput\u000a3\u000aabc\u000acbazyzabc\u000addaabbaacc\u000a\u000aOutput\u000a3\u000a6\u000a10\u000aExplanation\u000aFirst case: The string itself is LWS since it can be split into non-decreasing subsequence "abc" and non-increasing empty subsequence.\u000aSecond case: One of the possible LWS is "cbaabc" since it can be split as "cbaABC". Here we indicate by capital letters non-decreasing subsequence and by lowercase letters non-increasing one. Other possible LWS's are "cbaZZa", "AzyaBC".\u000aThird case: Here the desired splitting is "ddAABBaaCC".\u000aAuthor: vamsi_kavala\u000aTester: anton_lunyov\u000aEditorial: http://discuss.codechef.com/problems/LWS\u000aTags: easy march12 vamsi_kavala\u000aDate Added: 29-07-2011\u000aTime Limit: 3 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC\u000aSUBMIT All submissions for this problem are available.\u000aFinding the longest increasing subsequence is an old and well-known problem now. Here you will have to do something similar. You need to find the longest weird subsequence (LWS) of the given string. The subsequence is called weird if it can be split into two disjoint subsequences, one of which is non-decreasing and the other one is non-increasing.\u000aJust for clarity, by subsequence of the given string S we mean any string that can be obtained from S by erasing from it zero or more characters. So empty string is a subsequence of any string and any string is a subsequence of itself. Further, note that we consider only strings composed of lowercase Latin letters and these letters compared by their ASCII codes. So, for example, 'a' is smaller than 'b' and 'p' is larger than 'h'.\u000aNow let's consider some example. Let S="aabcazcczba". Then "abczz" is its some non-decreasing subsequene, "zccb" is its some non-increasing subsequence and "aabczcczba" is its some weird subsequence since it can be split into non-decreasing subsequence "aabzz" and non-increasing subsequence "cccba": "AABcZccZba" (first subsequence is shown by capital letters just for calrity).\u000aInput\u000aThe first line contains a single positive integer T, the number of test cases. T test cases follow. The only line of each test case contains a non-empty string S composed of lowercase Latin letters.\u000aOutput\u000aFor every test case, output the length of the LWS of the given string.\u000aConstraints\u000a1 \u2264 T \u2264 10\u000a1 \u2264 length of S \u2264 2000\u000aExample\u000aInput\u000a3\u000aabc\u000acbazyzabc\u000addaabbaacc\u000a\u000aOutput\u000a3\u000a6\u000a10\u000aExplanation\u000aFirst case: The string itself is LWS since it can be split into non-decreasing subsequence "abc" and non-increasing empty subsequence.\u000aSecond case: One of the possible LWS is "cbaabc" since it can be split as "cbaABC". Here we indicate by capital letters non-decreasing subsequence and by lowercase letters non-increasing one. Other possible LWS's are "cbaZZa", "AzyaBC".\u000aThird case: Here the desired splitting is "ddAABBaaCC".\u000aAuthor: vamsi_kavala\u000aTester: anton_lunyov\u000aEditorial: http://discuss.codechef.com/problems/LWS\u000aTags: easy march12 vamsi_kavala\u000aDate Added: 29-07-2011\u000aTime Limit: 3 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC All submissions for this problem are available. Finding the longest increasing subsequence is an old and well-known problem now. Here you will have to do something similar. You need to find the longest weird subsequence (LWS) of the given string. The subsequence is called weird if it can be split into two disjoint subsequences, one of which is non-decreasing and the other one is non-increasing. weird weird Just for clarity, by subsequence of the given string S we mean any string that can be obtained from S by erasing from it zero or more characters. So empty string is a subsequence of any string and any string is a subsequence of itself. Further, note that we consider only strings composed of lowercase Latin letters and these letters compared by their ASCII codes. So, for example, 'a' is smaller than 'b' and 'p' is larger than 'h'. S S Now let's consider some example. Let S="aabcazcczba". Then "abczz" is its some non-decreasing subsequene, "zccb" is its some non-increasing subsequence and "aabczcczba" is its some weird subsequence since it can be split into non-decreasing subsequence "aabzz" and non-increasing subsequence "cccba": "AABcZccZba" (first subsequence is shown by capital letters just for calrity). S="aabcazcczba" "abczz" "zccb" "aabczcczba" "aabzz" "cccba": "AABcZccZba" Input The first line contains a single positive integer T, the number of test cases. T test cases follow. The only line of each test case contains a non-empty string S composed of lowercase Latin letters. T T S Output  For every test case, output the length of the LWS of the given string. Constraints 1 \u2264 T \u2264 10\u000a1 \u2264 length of S \u2264 2000 T S Example Input\u000a3\u000aabc\u000acbazyzabc\u000addaabbaacc\u000a\u000aOutput\u000a3\u000a6\u000a10 Input Output Explanation First case: The string itself is LWS since it can be split into non-decreasing subsequence "abc" and non-increasing empty subsequence. First case: "abc" Second case: One of the possible LWS is "cbaabc" since it can be split as "cbaABC". Here we indicate by capital letters non-decreasing subsequence and by lowercase letters non-increasing one. Other possible LWS's are "cbaZZa", "AzyaBC". Second case: "cbaabc" "cbaABC" "cbaZZa", "AzyaBC" Third case: Here the desired splitting is "ddAABBaaCC". Third case: "ddAABBaaCC"  Author: vamsi_kavala\u000aTester: anton_lunyov\u000aEditorial: http://discuss.codechef.com/problems/LWS\u000aTags: easy march12 vamsi_kavala\u000aDate Added: 29-07-2011\u000aTime Limit: 3 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Author: vamsi_kavala\u000aTester: anton_lunyov\u000aEditorial: http://discuss.codechef.com/problems/LWS\u000aTags: easy march12 vamsi_kavala\u000aDate Added: 29-07-2011\u000aTime Limit: 3 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Author: vamsi_kavala Author: vamsi_kavala vamsi_kavala Tester: anton_lunyov Tester: anton_lunyov anton_lunyov Editorial: http://discuss.codechef.com/problems/LWS Editorial: http://discuss.codechef.com/problems/LWS http://discuss.codechef.com/problems/LWS Tags: easy march12 vamsi_kavala Tags: easy march12 vamsi_kavala easy march12 vamsi_kavala Date Added: 29-07-2011 Date Added: 29-07-2011 Time Limit: 3 sec Time Limit: 3 sec Source Limit: 50000 Bytes Source Limit: 50000 Bytes Languages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Languages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC SUBMIT  SUBMIT SUBMIT SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS  
p9
sS'tags'
p10
V easy march12 vamsi_kavala
p11
sS'url'
p12
Vhttps://www.codechef.com/problems/LWS
p13
sS'statement'
p14
(lp15
VAll submissions for this problem are available.
p16
aVFinding the longest increasing subsequence is an old and well-known problem now. Here you will have to do something similar. You need to find the longest weird subsequence (LWS) of the given string. The subsequence is called weird if it can be split into two disjoint subsequences, one of which is non-decreasing and the other one is non-increasing.
p17
aVJust for clarity, by subsequence of the given string S we mean any string that can be obtained from S by erasing from it zero or more characters. So empty string is a subsequence of any string and any string is a subsequence of itself. Further, note that we consider only strings composed of lowercase Latin letters and these letters compared by their ASCII codes. So, for example, 'a' is smaller than 'b' and 'p' is larger than 'h'.
p18
aVNow let's consider some example. Let S="aabcazcczba". Then "abczz" is its some non-decreasing subsequene, "zccb" is its some non-increasing subsequence and "aabczcczba" is its some weird subsequence since it can be split into non-decreasing subsequence "aabzz" and non-increasing subsequence "cccba": "AABcZccZba" (first subsequence is shown by capital letters just for calrity).
p19
asS'input'
p20
(lp21
VInput
p22
aVThe first line contains a single positive integer T, the number of test cases. T test cases follow. The only line of each test case contains a non-empty string S composed of lowercase Latin letters.
p23
aVOutput
p24
aVFor every test case, output the length of the LWS of the given string.
p25
asS'constraints'
p26
(lp27
VConstraints
p28
aV1 \u2264 T \u2264 10
p29
aV1 \u2264 length of S \u2264 2000
p30
asS'id'
p31
c__builtin__
id
p32
sS'name'
p33
VLWS
p34
sb.