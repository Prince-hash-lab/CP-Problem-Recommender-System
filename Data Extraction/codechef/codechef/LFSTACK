(iproblems
Problem
p0
(dp1
S'time_limit'
p2
(lp3
VTime Limit: 1 sec
p4
asS'source_limit'
p5
(lp6
VSource Limit: 50000 Bytes
p7
asS'description'
p8
V All submissions for this problem are available.\u000aRead problems statements in Mandarin Chinese, Russian and Vietnamese as well.\u000aSergey recently studied lock-free data structures. He particularly liked the data structure called Lock-Free Stack.\u000aSo, lock-free stack is basically an ordinary stack, which can be used by multiple threads of the same program. There are N threads, which do push and pop the numbers to this stack simultaneously.\u000aIn order to check his knowledge, Sergey implemented this data structure. But he was still unsure, whether his code works correct or not. So he made the test case of the following kind:\u000aFor every thread (say, the ith), there is a list of Ai numbers, which will be pushed to the stack by this thread in this order (so, first, the first number from this list will be added, then the second one, and so on).\u000aSo Sergey runs the program, the numbers get pushed to the stack from all the threads simultaneously. When all the threads are done with it, he wanted to pop all the numbers from the stack and to check the correctness of the output.\u000aBut it appeared to be not so easy problem, because in general, there could be a few different correct sequences he could obtain, because the order in which the processes add the numbers is not strictly defined. Moreover, the processes can interrupt in between.\u000aFor example, even if he had only two threads and for each of them, there was a list of 1 unique number, then there can be two valid orders: either the first thread added its' number first, or it was the second one.\u000aThe another example could be the following: if there are also two thread, the first one having the list (1, 2) and the second one having the list (3, 4), then after doing all pops even the sequence (4, 2, 3, 1) is correct, because in this case:\u000aFirst, the first thread added the first number 1 from its' list;\u000aThen, the second thread added the first number 3 from its' list;\u000aThen, the first thread added the second number 2 from its' list;\u000aThen, the second thread added the second number 4 from its' list;\u000aSo since it is a LIFO (last in, first out) stack, after the pops we get the sequence (4, 2, 3, 1).\u000aYou are given the number of the threads and the list of integers to be added in order for each of the threads. You are also given a sequence. Determine, whether this sequence could be obtained after the process described above.\u000aInput\u000aThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\u000aThe first line of each test case contains a single integer N denoting the number of threads.\u000aEach of the following N lines contains the description of the numbers to be pushed in the following way: the first number in the list is Ai; the following numbers are the numbers Bi, 1, Bi, 2, ..., Bi, Ai denoting the numbers that will be added to the stack (in this order) by the ith thread.\u000aThe last line on the test case contains A1+A2+...+AN integer numbers, denoting the sequence Sergey got after he popped all the numbers from the stack.\u000aOutput\u000aFor each test case, output a single line containing Yes, if Sergey could have got this sequence of numbers and No otherwise.\u000aConstraints\u000a1 \u2264 T \u2264 15\u000a1 \u2264 Ai\u000a1 \u2264 Bi, j \u2264 1000\u000aLet's denote P = (A1 + 1) × (A2 + 1) × ... × (AN + 1)\u000a1 \u2264 sum of P \u2264 106\u000aSubtaks\u000aSubtask #1 (33 points): 1 \u2264 sum of P \u2264 1000\u000aSubtask #2 (11 points): N = 1\u000aSubtask #3 (56 points): no additional constraints\u000aExample\u000aInput:\u000a2\u000a2\u000a2 1 2\u000a2 3 4\u000a4 3 2 1\u000a2\u000a2 1 2\u000a2 3 4\u000a4 1 2 3\u000a\u000aOutput:\u000aYes\u000aNo\u000aExplanation\u000aExample case 1. First, the integers of the first thread were added: 1, 2. Then, the integers of the second thread were added: 3, 4. So the sequence of the additions is 1, 2, 3, 4. Since it is a LIFO stack, when we pop, we get 4, 3, 2, 1. This way, the given sequence is reachable.\u000aExample case 2. We need to get the following sequence of pushes to the stack: 3, 2, 1, 4. So, 2 should be added before 1. But only the first thread in the example can add these integers, and it will add 2 only after it has added 1. So, the given configuration is impossible to obtain.\u000aAuthor: xcwgf666\u000aTester: harshil7924\u000aEditorial: http://discuss.codechef.com/problems/LFSTACK\u000aTags: dp ltime39 memoization recursion simple-easy xcwgf666\u000aDate Added: 6-08-2016\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYPY, PYTH, PYTH 3.4, RUBY, SCALA, SCM chicken, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC\u000aSUBMIT All submissions for this problem are available.\u000aRead problems statements in Mandarin Chinese, Russian and Vietnamese as well.\u000aSergey recently studied lock-free data structures. He particularly liked the data structure called Lock-Free Stack.\u000aSo, lock-free stack is basically an ordinary stack, which can be used by multiple threads of the same program. There are N threads, which do push and pop the numbers to this stack simultaneously.\u000aIn order to check his knowledge, Sergey implemented this data structure. But he was still unsure, whether his code works correct or not. So he made the test case of the following kind:\u000aFor every thread (say, the ith), there is a list of Ai numbers, which will be pushed to the stack by this thread in this order (so, first, the first number from this list will be added, then the second one, and so on).\u000aSo Sergey runs the program, the numbers get pushed to the stack from all the threads simultaneously. When all the threads are done with it, he wanted to pop all the numbers from the stack and to check the correctness of the output.\u000aBut it appeared to be not so easy problem, because in general, there could be a few different correct sequences he could obtain, because the order in which the processes add the numbers is not strictly defined. Moreover, the processes can interrupt in between.\u000aFor example, even if he had only two threads and for each of them, there was a list of 1 unique number, then there can be two valid orders: either the first thread added its' number first, or it was the second one.\u000aThe another example could be the following: if there are also two thread, the first one having the list (1, 2) and the second one having the list (3, 4), then after doing all pops even the sequence (4, 2, 3, 1) is correct, because in this case:\u000aFirst, the first thread added the first number 1 from its' list;\u000aThen, the second thread added the first number 3 from its' list;\u000aThen, the first thread added the second number 2 from its' list;\u000aThen, the second thread added the second number 4 from its' list;\u000aSo since it is a LIFO (last in, first out) stack, after the pops we get the sequence (4, 2, 3, 1).\u000aYou are given the number of the threads and the list of integers to be added in order for each of the threads. You are also given a sequence. Determine, whether this sequence could be obtained after the process described above.\u000aInput\u000aThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\u000aThe first line of each test case contains a single integer N denoting the number of threads.\u000aEach of the following N lines contains the description of the numbers to be pushed in the following way: the first number in the list is Ai; the following numbers are the numbers Bi, 1, Bi, 2, ..., Bi, Ai denoting the numbers that will be added to the stack (in this order) by the ith thread.\u000aThe last line on the test case contains A1+A2+...+AN integer numbers, denoting the sequence Sergey got after he popped all the numbers from the stack.\u000aOutput\u000aFor each test case, output a single line containing Yes, if Sergey could have got this sequence of numbers and No otherwise.\u000aConstraints\u000a1 \u2264 T \u2264 15\u000a1 \u2264 Ai\u000a1 \u2264 Bi, j \u2264 1000\u000aLet's denote P = (A1 + 1) × (A2 + 1) × ... × (AN + 1)\u000a1 \u2264 sum of P \u2264 106\u000aSubtaks\u000aSubtask #1 (33 points): 1 \u2264 sum of P \u2264 1000\u000aSubtask #2 (11 points): N = 1\u000aSubtask #3 (56 points): no additional constraints\u000aExample\u000aInput:\u000a2\u000a2\u000a2 1 2\u000a2 3 4\u000a4 3 2 1\u000a2\u000a2 1 2\u000a2 3 4\u000a4 1 2 3\u000a\u000aOutput:\u000aYes\u000aNo\u000aExplanation\u000aExample case 1. First, the integers of the first thread were added: 1, 2. Then, the integers of the second thread were added: 3, 4. So the sequence of the additions is 1, 2, 3, 4. Since it is a LIFO stack, when we pop, we get 4, 3, 2, 1. This way, the given sequence is reachable.\u000aExample case 2. We need to get the following sequence of pushes to the stack: 3, 2, 1, 4. So, 2 should be added before 1. But only the first thread in the example can add these integers, and it will add 2 only after it has added 1. So, the given configuration is impossible to obtain.\u000aAuthor: xcwgf666\u000aTester: harshil7924\u000aEditorial: http://discuss.codechef.com/problems/LFSTACK\u000aTags: dp ltime39 memoization recursion simple-easy xcwgf666\u000aDate Added: 6-08-2016\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYPY, PYTH, PYTH 3.4, RUBY, SCALA, SCM chicken, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well. Mandarin Chinese Russian Vietnamese Sergey recently studied lock-free data structures. He particularly liked the data structure called Lock-Free Stack. So, lock-free stack is basically an ordinary stack, which can be used by multiple threads of the same program. There are N threads, which do push and pop the numbers to this stack simultaneously. N In order to check his knowledge, Sergey implemented this data structure. But he was still unsure, whether his code works correct or not. So he made the test case of the following kind: For every thread (say, the ith), there is a list of Ai numbers, which will be pushed to the stack by this thread in this order (so, first, the first number from this list will be added, then the second one, and so on). For every thread (say, the ith), there is a list of Ai numbers, which will be pushed to the stack by this thread in this order (so, first, the first number from this list will be added, then the second one, and so on). ith th Ai i  So Sergey runs the program, the numbers get pushed to the stack from all the threads simultaneously. When all the threads are done with it, he wanted to pop all the numbers from the stack and to check the correctness of the output. But it appeared to be not so easy problem, because in general, there could be a few different correct sequences he could obtain, because the order in which the processes add the numbers is not strictly defined. Moreover, the processes can interrupt in between. For example, even if he had only two threads and for each of them, there was a list of 1 unique number, then there can be two valid orders: either the first thread added its' number first, or it was the second one. 1 The another example could be the following: if there are also two thread, the first one having the list (1, 2) and the second one having the list (3, 4), then after doing all pops even the sequence (4, 2, 3, 1) is correct, because in this case: (1, 2) (3, 4) (4, 2, 3, 1) First, the first thread added the first number 1 from its' list;\u000aThen, the second thread added the first number 3 from its' list;\u000aThen, the first thread added the second number 2 from its' list;\u000aThen, the second thread added the second number 4 from its' list; First, the first thread added the first number 1 from its' list; 1 Then, the second thread added the first number 3 from its' list; 3 Then, the first thread added the second number 2 from its' list; 2 Then, the second thread added the second number 4 from its' list; 4 (4, 2, 3, 1)  You are given the number of the threads and the list of integers to be added in order for each of the threads. You are also given a sequence. Determine, whether this sequence could be obtained after the process described above. Input The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. T T The first line of each test case contains a single integer N denoting the number of threads. N Each of the following N lines contains the description of the numbers to be pushed in the following way: the first number in the list is Ai; the following numbers are the numbers Bi, 1, Bi, 2, ..., Bi, Ai denoting the numbers that will be added to the stack (in this order) by the ith thread. N Ai i Bi, 1 i, 1 Bi, 2 i, 2 Bi, Ai i, Ai i i th The last line on the test case contains A1+A2+...+AN integer numbers, denoting the sequence Sergey got after he popped all the numbers from the stack. A1 1 A2 2 AN N Output For each test case, output a single line containing Yes, if Sergey could have got this sequence of numbers and No otherwise. Yes No Constraints 1 \u2264 T \u2264 15\u000a1 \u2264 Ai\u000a1 \u2264 Bi, j \u2264 1000\u000aLet's denote P = (A1 + 1) × (A2 + 1) × ... × (AN + 1)\u000a1 \u2264 sum of P \u2264 106 1 \u2264 T \u2264 15 1 T 15 1 \u2264 Ai 1 Ai i 1 \u2264 Bi, j \u2264 1000 1 Bi, j i, j 1000 Let's denote P = (A1 + 1) × (A2 + 1) × ... × (AN + 1) P (A1 + 1) × (A2 + 1) × ... × (AN + 1) 1 2 N 1 \u2264 sum of P \u2264 106 1 P 106 6 Subtaks Subtask #1 (33 points): 1 \u2264 sum of P \u2264 1000\u000aSubtask #2 (11 points): N = 1\u000aSubtask #3 (56 points): no additional constraints Subtask #1 (33 points): 1 \u2264 sum of P \u2264 1000 Subtask #1 (33 points) 1 P 1000 Subtask #2 (11 points): N = 1 Subtask #2 (11 points) N 1 Subtask #3 (56 points): no additional constraints Subtask #3 (56 points) Example Input:\u000a2\u000a2\u000a2 1 2\u000a2 3 4\u000a4 3 2 1\u000a2\u000a2 1 2\u000a2 3 4\u000a4 1 2 3\u000a\u000aOutput:\u000aYes\u000aNo Input: 2\u000a2\u000a2 1 2\u000a2 3 4\u000a4 3 2 1\u000a2\u000a2 1 2\u000a2 3 4\u000a4 1 2 3 Output: Yes\u000aNo Explanation Example case 1. First, the integers of the first thread were added: 1, 2. Then, the integers of the second thread were added: 3, 4. So the sequence of the additions is 1, 2, 3, 4. Since it is a LIFO stack, when we pop, we get 4, 3, 2, 1. This way, the given sequence is reachable. Example case 1. 1, 2 3, 4 1, 2, 3, 4 4, 3, 2, 1 Example case 2. We need to get the following sequence of pushes to the stack: 3, 2, 1, 4. So, 2 should be added before 1. But only the first thread in the example can add these integers, and it will add 2 only after it has added 1. So, the given configuration is impossible to obtain. Example case 2. 3, 2, 1, 4 2 1 2 after 1  Author: xcwgf666\u000aTester: harshil7924\u000aEditorial: http://discuss.codechef.com/problems/LFSTACK\u000aTags: dp ltime39 memoization recursion simple-easy xcwgf666\u000aDate Added: 6-08-2016\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYPY, PYTH, PYTH 3.4, RUBY, SCALA, SCM chicken, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Author: xcwgf666\u000aTester: harshil7924\u000aEditorial: http://discuss.codechef.com/problems/LFSTACK\u000aTags: dp ltime39 memoization recursion simple-easy xcwgf666\u000aDate Added: 6-08-2016\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYPY, PYTH, PYTH 3.4, RUBY, SCALA, SCM chicken, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Author: xcwgf666 Author: xcwgf666 xcwgf666 Tester: harshil7924 Tester: harshil7924 harshil7924 Editorial: http://discuss.codechef.com/problems/LFSTACK Editorial: http://discuss.codechef.com/problems/LFSTACK http://discuss.codechef.com/problems/LFSTACK Tags: dp ltime39 memoization recursion simple-easy xcwgf666 Tags: dp ltime39 memoization recursion simple-easy xcwgf666 dp ltime39 memoization recursion simple-easy xcwgf666 Date Added: 6-08-2016 Date Added: 6-08-2016 Time Limit: 1 sec Time Limit: 1 sec Source Limit: 50000 Bytes Source Limit: 50000 Bytes Languages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYPY, PYTH, PYTH 3.4, RUBY, SCALA, SCM chicken, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Languages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYPY, PYTH, PYTH 3.4, RUBY, SCALA, SCM chicken, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC SUBMIT  SUBMIT SUBMIT SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS  
p9
sS'tags'
p10
V dp ltime39 memoization recursion simple-easy xcwgf666
p11
sS'url'
p12
Vhttps://www.codechef.com/problems/LFSTACK
p13
sS'statement'
p14
(lp15
VAll submissions for this problem are available.
p16
aVRead problems statements in Mandarin Chinese, Russian and Vietnamese as well.
p17
aVSergey recently studied lock-free data structures. He particularly liked the data structure called Lock-Free Stack.
p18
aVSo, lock-free stack is basically an ordinary stack, which can be used by multiple threads of the same program. There are N threads, which do push and pop the numbers to this stack simultaneously.
p19
aVIn order to check his knowledge, Sergey implemented this data structure. But he was still unsure, whether his code works correct or not. So he made the test case of the following kind:
p20
aVFor every thread (say, the ith), there is a list of Ai numbers, which will be pushed to the stack by this thread in this order (so, first, the first number from this list will be added, then the second one, and so on).
p21
aVSo Sergey runs the program, the numbers get pushed to the stack from all the threads simultaneously. When all the threads are done with it, he wanted to pop all the numbers from the stack and to check the correctness of the output.
p22
aVBut it appeared to be not so easy problem, because in general, there could be a few different correct sequences he could obtain, because the order in which the processes add the numbers is not strictly defined. Moreover, the processes can interrupt in between.
p23
aVFor example, even if he had only two threads and for each of them, there was a list of 1 unique number, then there can be two valid orders: either the first thread added its' number first, or it was the second one.
p24
aVThe another example could be the following: if there are also two thread, the first one having the list (1, 2) and the second one having the list (3, 4), then after doing all pops even the sequence (4, 2, 3, 1) is correct, because in this case:
p25
aVFirst, the first thread added the first number 1 from its' list;
p26
aVThen, the second thread added the first number 3 from its' list;
p27
aVThen, the first thread added the second number 2 from its' list;
p28
aVThen, the second thread added the second number 4 from its' list;
p29
aVSo since it is a LIFO (last in, first out) stack, after the pops we get the sequence (4, 2, 3, 1).
p30
aVYou are given the number of the threads and the list of integers to be added in order for each of the threads. You are also given a sequence. Determine, whether this sequence could be obtained after the process described above.
p31
asS'input'
p32
(lp33
VInput
p34
aVThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
p35
aVThe first line of each test case contains a single integer N denoting the number of threads.
p36
aVEach of the following N lines contains the description of the numbers to be pushed in the following way: the first number in the list is Ai; the following numbers are the numbers Bi, 1, Bi, 2, ..., Bi, Ai denoting the numbers that will be added to the stack (in this order) by the ith thread.
p37
aVThe last line on the test case contains A1+A2+...+AN integer numbers, denoting the sequence Sergey got after he popped all the numbers from the stack.
p38
aVOutput
p39
aVFor each test case, output a single line containing Yes, if Sergey could have got this sequence of numbers and No otherwise.
p40
asS'constraints'
p41
(lp42
VConstraints
p43
aV1 \u2264 T \u2264 15
p44
aV1 \u2264 Ai
p45
aV1 \u2264 Bi, j \u2264 1000
p46
aVLet's denote P = (A1 + 1) × (A2 + 1) × ... × (AN + 1)
p47
aV1 \u2264 sum of P \u2264 106
p48
aVSubtaks
p49
aVSubtask #1 (33 points): 1 \u2264 sum of P \u2264 1000
p50
aVSubtask #2 (11 points): N = 1
p51
aVSubtask #3 (56 points): no additional constraints
p52
asS'id'
p53
c__builtin__
id
p54
sS'name'
p55
VLFSTACK
p56
sb.