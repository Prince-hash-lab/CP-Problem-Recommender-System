(iproblems
Problem
p0
(dp1
S'time_limit'
p2
(lp3
VTime Limit: 1 sec
p4
asS'source_limit'
p5
(lp6
VSource Limit: 50000 Bytes
p7
asS'description'
p8
V All submissions for this problem are available.\u000aThe Little Elephant loves lucky strings. Everybody knows that the lucky string is a string of digits that contains only the lucky digits 4 and 7. For example, strings "47", "744", "4" are lucky while "5", "17", "467" are not.\u000aThe Little Elephant has the strings A and B of digits. These strings are of equal lengths, that is |A| = |B|. He wants to get some lucky string from them. For this he performs the following operations. At first he arbitrary reorders digits of A. Then he arbitrary reorders digits of B. After that he creates the string C such that its i-th digit is the maximum between the i-th digit of A and the i-th digit of B. In other words, C[i] = max{A[i], B[i]} for i from 1 to |A|. After that he removes from C all non-lucky digits saving the order of the remaining (lucky) digits. So C now becomes a lucky string. For example, if after reordering A = "754" and B = "873", then C is at first "874" and then it becomes "74".\u000aThe Little Elephant wants the resulting string to be as lucky as possible. The formal definition of this is that the resulting string should be the lexicographically greatest possible string among all the strings that can be obtained from the given strings A and B by the described process.\u000aNotes\u000a|A| denotes the length of the string A.\u000aA[i] denotes the i-th digit of the string A. Here we numerate the digits starting from 1. So 1 \u2264 i \u2264 |A|.\u000aThe string A is called lexicographically greater than the string B if either there exists some index i such that A[i] > B[i] and for each j < i we have A[j] = B[j], or B is a proper prefix of A, that is, |A| > |B| and first |B| digits of A coincide with the corresponding digits of B.\u000aInput\u000aThe first line of the input contains a single integer T, the number of test cases. T test cases follow. Each test case consists of two lines. The first line contains the string A. The second line contains the string B.\u000aOutput\u000aFor each test case output a single line containing the answer for the corresponding test case. Note, that the answer can be an empty string. In this case you should print an empty line for the corresponding test case.\u000aConstraints\u000a1 \u2264 T \u2264 10000\u000a1 \u2264 |A| \u2264 20000\u000a|A| = |B|\u000aEach character of A and B is a digit.\u000aSum of |A| across all the tests in the input does not exceed 200000.\u000aExample\u000aInput:\u000a4\u000a4\u000a7\u000a435\u000a479\u000a7\u000a8\u000a1675475\u000a9756417\u000a\u000aOutput:\u000a7\u000a74\u000a\u000a777744\u000aExplanation\u000aCase 1. In this case the only possible string C we can get is "7" and it is the lucky string.\u000aCase 2. If we reorder A and B as A = "543" and B = "749" the string C will be at first "749" and then becomes "74". It can be shown that this is the lexicographically greatest string for the given A and B.\u000aCase 3. In this case the only possible string C we can get is "8" and it becomes and empty string after removing of non-lucky digits.\u000aCase 4. If we reorder A and B as A = "7765541" and B = "5697714" the string C will be at first "7797744" and then becomes "777744". Note that we can construct any lexicographically greater string for the given A and B since we have only four "sevens" and two "fours" among digits of both strings A and B as well the constructed string "777744".\u000aAuthor: witua\u000aTags: easy greedy oct12 witua\u000aDate Added: 17-02-2012\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC\u000aSUBMIT All submissions for this problem are available.\u000aThe Little Elephant loves lucky strings. Everybody knows that the lucky string is a string of digits that contains only the lucky digits 4 and 7. For example, strings "47", "744", "4" are lucky while "5", "17", "467" are not.\u000aThe Little Elephant has the strings A and B of digits. These strings are of equal lengths, that is |A| = |B|. He wants to get some lucky string from them. For this he performs the following operations. At first he arbitrary reorders digits of A. Then he arbitrary reorders digits of B. After that he creates the string C such that its i-th digit is the maximum between the i-th digit of A and the i-th digit of B. In other words, C[i] = max{A[i], B[i]} for i from 1 to |A|. After that he removes from C all non-lucky digits saving the order of the remaining (lucky) digits. So C now becomes a lucky string. For example, if after reordering A = "754" and B = "873", then C is at first "874" and then it becomes "74".\u000aThe Little Elephant wants the resulting string to be as lucky as possible. The formal definition of this is that the resulting string should be the lexicographically greatest possible string among all the strings that can be obtained from the given strings A and B by the described process.\u000aNotes\u000a|A| denotes the length of the string A.\u000aA[i] denotes the i-th digit of the string A. Here we numerate the digits starting from 1. So 1 \u2264 i \u2264 |A|.\u000aThe string A is called lexicographically greater than the string B if either there exists some index i such that A[i] > B[i] and for each j < i we have A[j] = B[j], or B is a proper prefix of A, that is, |A| > |B| and first |B| digits of A coincide with the corresponding digits of B.\u000aInput\u000aThe first line of the input contains a single integer T, the number of test cases. T test cases follow. Each test case consists of two lines. The first line contains the string A. The second line contains the string B.\u000aOutput\u000aFor each test case output a single line containing the answer for the corresponding test case. Note, that the answer can be an empty string. In this case you should print an empty line for the corresponding test case.\u000aConstraints\u000a1 \u2264 T \u2264 10000\u000a1 \u2264 |A| \u2264 20000\u000a|A| = |B|\u000aEach character of A and B is a digit.\u000aSum of |A| across all the tests in the input does not exceed 200000.\u000aExample\u000aInput:\u000a4\u000a4\u000a7\u000a435\u000a479\u000a7\u000a8\u000a1675475\u000a9756417\u000a\u000aOutput:\u000a7\u000a74\u000a\u000a777744\u000aExplanation\u000aCase 1. In this case the only possible string C we can get is "7" and it is the lucky string.\u000aCase 2. If we reorder A and B as A = "543" and B = "749" the string C will be at first "749" and then becomes "74". It can be shown that this is the lexicographically greatest string for the given A and B.\u000aCase 3. In this case the only possible string C we can get is "8" and it becomes and empty string after removing of non-lucky digits.\u000aCase 4. If we reorder A and B as A = "7765541" and B = "5697714" the string C will be at first "7797744" and then becomes "777744". Note that we can construct any lexicographically greater string for the given A and B since we have only four "sevens" and two "fours" among digits of both strings A and B as well the constructed string "777744".\u000aAuthor: witua\u000aTags: easy greedy oct12 witua\u000aDate Added: 17-02-2012\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC All submissions for this problem are available. The Little Elephant loves lucky strings. Everybody knows that the lucky string is a string of digits that contains only the lucky digits 4 and 7. For example, strings "47", "744", "4" are lucky while "5", "17", "467" are not. 4 7 "47" "744" "4" "5" "17" "467" The Little Elephant has the strings A and B of digits. These strings are of equal lengths, that is |A| = |B|. He wants to get some lucky string from them. For this he performs the following operations. At first he arbitrary reorders digits of A. Then he arbitrary reorders digits of B. After that he creates the string C such that its i-th digit is the maximum between the i-th digit of A and the i-th digit of B. In other words, C[i] = max{A[i], B[i]} for i from 1 to |A|. After that he removes from C all non-lucky digits saving the order of the remaining (lucky) digits. So C now becomes a lucky string. For example, if after reordering A = "754" and B = "873", then C is at first "874" and then it becomes "74". A B |A| |B| A B C i i A i B C i max A i B i i 1 A C C A = "754" B = "873" C "874" "74" The Little Elephant wants the resulting string to be as lucky as possible. The formal definition of this is that the resulting string should be the lexicographically greatest possible string among all the strings that can be obtained from the given strings A and B by the described process. A B Notes |A| denotes the length of the string A.\u000aA[i] denotes the i-th digit of the string A. Here we numerate the digits starting from 1. So 1 \u2264 i \u2264 |A|.\u000aThe string A is called lexicographically greater than the string B if either there exists some index i such that A[i] > B[i] and for each j < i we have A[j] = B[j], or B is a proper prefix of A, that is, |A| > |B| and first |B| digits of A coincide with the corresponding digits of B. |A| denotes the length of the string A. |A| A A[i] denotes the i-th digit of the string A. Here we numerate the digits starting from 1. So 1 \u2264 i \u2264 |A|. A i i A 1 1 i A The string A is called lexicographically greater than the string B if either there exists some index i such that A[i] > B[i] and for each j < i we have A[j] = B[j], or B is a proper prefix of A, that is, |A| > |B| and first |B| digits of A coincide with the corresponding digits of B. A B i A[i] > B[i] j < i A[j] = B[j] B A A B B A B Input The first line of the input contains a single integer T, the number of test cases. T test cases follow. Each test case consists of two lines. The first line contains the string A. The second line contains the string B. T T A B Output For each test case output a single line containing the answer for the corresponding test case. Note, that the answer can be an empty string. In this case you should print an empty line for the corresponding test case. Constraints 1 \u2264 T \u2264 10000\u000a1 \u2264 |A| \u2264 20000\u000a|A| = |B|\u000aEach character of A and B is a digit.\u000aSum of |A| across all the tests in the input does not exceed 200000. 1 T 10000  1 |A| 20000  A B  A B  A 200000 Example Input:\u000a4\u000a4\u000a7\u000a435\u000a479\u000a7\u000a8\u000a1675475\u000a9756417\u000a\u000aOutput:\u000a7\u000a74\u000a\u000a777744 Input: Output: Explanation Case 1. In this case the only possible string C we can get is "7" and it is the lucky string. Case 1. C "7" Case 2. If we reorder A and B as A = "543" and B = "749" the string C will be at first "749" and then becomes "74". It can be shown that this is the lexicographically greatest string for the given A and B. Case 2. A B A = "543" B = "749" C "749" "74" A B Case 3. In this case the only possible string C we can get is "8" and it becomes and empty string after removing of non-lucky digits. Case 3. C "8" Case 4. If we reorder A and B as A = "7765541" and B = "5697714" the string C will be at first "7797744" and then becomes "777744". Note that we can construct any lexicographically greater string for the given A and B since we have only four "sevens" and two "fours" among digits of both strings A and B as well the constructed string "777744". Case 4. A B A = "7765541" B = "5697714" C "7797744" "777744" A B A B "777744"  Author: witua\u000aTags: easy greedy oct12 witua\u000aDate Added: 17-02-2012\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Author: witua\u000aTags: easy greedy oct12 witua\u000aDate Added: 17-02-2012\u000aTime Limit: 1 sec\u000aSource Limit: 50000 Bytes\u000aLanguages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Author: witua Author: witua witua Tags: easy greedy oct12 witua Tags: easy greedy oct12 witua easy greedy oct12 witua Date Added: 17-02-2012 Date Added: 17-02-2012 Time Limit: 1 sec Time Limit: 1 sec Source Limit: 50000 Bytes Source Limit: 50000 Bytes Languages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC Languages: ADA, ASM, BASH, BF, C, C99 strict, CAML, CLOJ, CLPS, CPP 4.3.2, CPP 4.9.2, CPP14, CS2, D, ERL, FORT, FS, GO, HASK, ICK, ICON, JAVA, JS, LISP clisp, LISP sbcl, LUA, NEM, NICE, NODEJS, PAS fpc, PAS gpc, PERL, PERL6, PHP, PIKE, PRLG, PYTH, PYTH 3.4, RUBY, SCALA, SCM guile, SCM qobi, ST, TCL, TEXT, WSPC SUBMIT  SUBMIT SUBMIT SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS SUCCESSFUL SUBMISSIONS  
p9
sS'tags'
p10
V easy greedy oct12 witua
p11
sS'url'
p12
Vhttps://www.codechef.com/problems/LUCKY10
p13
sS'statement'
p14
(lp15
VAll submissions for this problem are available.
p16
aVThe Little Elephant loves lucky strings. Everybody knows that the lucky string is a string of digits that contains only the lucky digits 4 and 7. For example, strings "47", "744", "4" are lucky while "5", "17", "467" are not.
p17
aVThe Little Elephant has the strings A and B of digits. These strings are of equal lengths, that is |A| = |B|. He wants to get some lucky string from them. For this he performs the following operations. At first he arbitrary reorders digits of A. Then he arbitrary reorders digits of B. After that he creates the string C such that its i-th digit is the maximum between the i-th digit of A and the i-th digit of B. In other words, C[i] = max{A[i], B[i]} for i from 1 to |A|. After that he removes from C all non-lucky digits saving the order of the remaining (lucky) digits. So C now becomes a lucky string. For example, if after reordering A = "754" and B = "873", then C is at first "874" and then it becomes "74".
p18
aVThe Little Elephant wants the resulting string to be as lucky as possible. The formal definition of this is that the resulting string should be the lexicographically greatest possible string among all the strings that can be obtained from the given strings A and B by the described process.
p19
aVNotes
p20
aV|A| denotes the length of the string A.
p21
aVA[i] denotes the i-th digit of the string A. Here we numerate the digits starting from 1. So 1 \u2264 i \u2264 |A|.
p22
aVThe string A is called lexicographically greater than the string B if either there exists some index i such that A[i] > B[i] and for each j < i we have A[j] = B[j], or B is a proper prefix of A, that is, |A| > |B| and first |B| digits of A coincide with the corresponding digits of B.
p23
asS'input'
p24
(lp25
VInput
p26
aVThe first line of the input contains a single integer T, the number of test cases. T test cases follow. Each test case consists of two lines. The first line contains the string A. The second line contains the string B.
p27
aVOutput
p28
aVFor each test case output a single line containing the answer for the corresponding test case. Note, that the answer can be an empty string. In this case you should print an empty line for the corresponding test case.
p29
asS'constraints'
p30
(lp31
VConstraints
p32
aV1 \u2264 T \u2264 10000
p33
aV1 \u2264 |A| \u2264 20000
p34
aV|A| = |B|
p35
aVEach character of A and B is a digit.
p36
aVSum of |A| across all the tests in the input does not exceed 200000.
p37
asS'id'
p38
c__builtin__
id
p39
sS'name'
p40
VLUCKY10
p41
sb.